# Fablab 아키텍처 전환에 대한 제언

사용자께서 제시하신 **"Go 코드로 빌드된 개별 실행 파일(Imperative)"** 방식에서 **"설정 파일 기반의 공통 실행 파일(Declarative)"** 방식으로 전환하고, 이를 통해 **OpenZiti 네트워크의 상시 운용**을 지원하는 방향에 대한 분석과 의견입니다.

## 1. 핵심 변화 분석

### 기존 방식 (Code-centric)
*   **구조**: `main.go`에 모델 정의 -> `go build` -> `binary` 생성 -> CLI로 제어.
*   **특징**: 프로그래머에게 무한한 자유도 제공. 컴파일 타임에 타입 체크 가능.
*   **한계**: 운영팀이 Go 언어를 알아야 함. 배포 때마다 컴파일 필요. CI/CD 파이프라인 통합이 까다로움.

### 변경 제안 방식 (Data-centric / Configuration-driven)
*   **구조**: `config.yaml` 작성 -> `fablab-manager`(공용 바이너리)가 로드 -> 동적 인스턴스 생성 -> 제어.
*   **특징**: 운영 표준(Kubernetes, Ansible 스타일). GitOps 친화적.
*   **장점**: 재컴파일 없이 설정 변경만으로 배포 수정 가능.

---

## 2. 주요 포인트별 의견 및 제언

### A. OpenZiti Network 배포/제거 (Lifecycle Management)
OpenZiti는 복잡한 상호 의존성(CA -> Controller -> Router -> Edge)을 가집니다.

*   **의견**: **"단순 스크립트"에서 "상태 조정자(Reconciler)"로의 진화가 필수적입니다.**
    *   기존의 `create`, `delete` 명령어는 일회성 테스트에는 적합하지만, 프로덕션 배포/제거에는 위험합니다.
    *   설정 파일 방식 도입 시, 단순한 배포/제거를 넘어 **"선언적 상태(Desired State)"** 개념을 도입해야 합니다.
    *   예: "라우터를 3개로 설정"하면, 현재 2개일 때 1개만 추가하는 로직이 필요합니다.

### B. 상시 서비스 (Always-on Service)
테스트용 일회성 네트워크가 아니라, 실제 서비스용 네트워크를 구축하려는 목표입니다.

*   **의견**: **상태 저장소(State Persistence)의 분리가 핵심입니다.**
    *   **문제점**: 실행 파일 방식에서는 상태 정보가 로컬 파일이나 메모리에 의존적인 경우가 많아, 프로세스가 종료되거나 서버가 바뀌면 관리가 불가능해질 수 있습니다.
    *   **해결책**: 설정 파일(YAML) 방식으로 가면 필연적으로 현재 인프라의 상태(State)를 저장할 곳이 필요합니다. (Git에는 '목표 상태'를 저장하고, 실제 '운영 상태'는 DB, ETCD, 혹은 S3 등에 저장)
    *   Daemon 형태의 `fablab-agent`가 백그라운드에서 돌면서 시스템을 감시하거나, Systemd/K8s 등을 활용해 프로세스 수명을 관리해야 합니다.

### C. 실행 파일(`main.go`) vs 설정 파일(`yaml`)
가장 큰 구조적 변화입니다.

*   **강력한 찬성 (Strongly Recommended)**:
    *   현대적인 DevOps/SRA 팀은 인프라를 코드가 아닌 **데이터(YAML/JSON)**로 관리하는 것을 선호합니다.
    *   **GitOps**: "설정 파일" 방식이어야만 Git 저장소에 배포 명세서를 올리고, ArgoCD나 Jenkins가 이를 자동으로 반영하는 구조를 짤 수 있습니다. 바이너리 방식은 GitOps 구현이 매우 어렵습니다.
    *   **버전 관리**: 인프라 변경 이력을 Git Commmit `diff`로 명확하게 볼 수 있습니다.

*   **주의할 점 (Trade-offs)**:
    *   **동적 로직의 상실**: Go 코드에서는 `for` 루프나 `if` 조건문을 자유롭게 썼지만, YAML은 정적입니다. 이를 보완하기 위해 **Template Engine (Go Template, Helm 등)** 도입이나, **간단한 스크립팅 지원**이 필요할 수 있습니다.
    *   **Type Registry 구현**: YAML의 문자열(`type: aws-host`)을 내부 Go 구조체로 매핑해주는 **Dynamic Registry** 구현 난이도가 있습니다.

---

## 3. 종합 제언 (Roadmap)

사용자의 제안은 **Fablab을 "개발 도구"에서 "운영 플랫폼"으로 격상시키는 올바른 방향**입니다. 다음과 같은 아키텍처 전환을 추천합니다.

1.  **Phase 1: Dual Mode 지원 (하이브리드)**
    *   급격한 전환보다는, `main.go`가 `config.yaml`을 읽어서 모델을 구성하도록 수정하여, 코드로도 짤 수 있고 YAML도 읽을 수 있는 과도기 단계를 거칩니다.

2.  **Phase 2: Common Runtime 개발**
    *   OpenZiti 배포 및 관리를 위한 로직이 내장된 범용 `fablab` 바이너리를 배포합니다.
    *   이 바이너리는 `model.yaml` (설정)을 입력받아 동작합니다.

3.  **Phase 3: Operator Pattern 도입**
    *   상시 서비스를 위해, 사용자가 명령을 내릴 때만 도는 것이 아니라, 상주하는 프로그램(Operator/Controller)이 지속적으로 YAML 설정과 실제 인프라 상태를 일치시킵니다.

### 결론
**"설정 파일 기반 배포 방식"으로의 변경은 OpenZiti 네트워크의 상용화 및 대규모 운영 자동화를 위해 반드시 가야 할 길입니다.**
